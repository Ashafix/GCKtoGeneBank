package gck_convert;

import java.io.FileInputStream;
import gckfilestructure.*;
import java.io.IOException;
import java.util.logging.Logger;
import java.nio.ByteBuffer;
import java.io.File;
import java.io.PrintWriter;

/**
 * Reads and extracts data from a gck sequence file.
 * 
 * The extracted data is stored in an associated GCKFile object.
 * Contains methods to extract information about regions and features.
 * Marks or enzyme cleavage sites cannot be extracted at this time.
 * 
 * @author Matyas Medzihradszky
 * @version 0.1
 * 
 * @version 1.0
 * Stable first release
 * 
 * @version 1.1
 * - bug: Start of features and regions one nucleotide too early. Probably
 *        in the GCK file, the first number is the left border of where it
 *        starts.
 *   - solution: +1 added to the functions to set start of regions and features (Line 120, 189).
 */
public class GCKFileAnalyzer {
    
    public GCKFileAnalyzer(GCKFile gckFile) throws IOException{
        super();
        this.gckFile = gckFile;
        fileInputStream = new FileInputStream(gckFile.getFile());
        debugStatus = false;
    }

    public void readGCKFile() {
        readFileHeader();
        readSequence();
        readRegions();
        readFeatures();
        readFeatureNamesAndComments();
    }

    /**
     * Reads basic information about the file to be analyzed.
     * 
     * Reads the stored sequence length, the length of the feature definitions,
     * and the length of region definitions. These are later used to move around
     * in the file to the relevant positions.<br />
     * 
     * <b>IMPORTANT: Must be called before any other methods of the class can be 
     * used reliably.</b>
     */
    private void readFileHeader() {
        logger.info("Reading file header.");
        buffer = ByteBuffer.allocate(gckFile.getHeader().getHEADER_SIZE());
        try {
            //Set read position to the start of the file.
            fileInputStream.getChannel().position(0);
            
            //Read sequence length data.
            fileInputStream.read(buffer.array(), 0, gckFile.getHeader().getHEADER_SIZE());
            gckFile.getSequence().setLength(buffer.getInt(buffer.capacity()-(Integer.SIZE/8)));
            if (debugStatus) { debugWriter.println("Sequence length = " + gckFile.getSequence().getLength()); }
            
            //Read length of region definitions.
            fileInputStream.skip(gckFile.getSequence().getLength());
            fileInputStream.read(buffer.array(), 0, 4);
            gckFile.setLengthRegions(buffer.getInt(0));
            if (debugStatus) { debugWriter.println("Regions length = " + gckFile.getLengthRegions()); }
            
            //Read length of feature definitions.
            fileInputStream.skip(gckFile.getLengthRegions());
            fileInputStream.read(buffer.array(), 0, 4);
            gckFile.setLengthFeatures(buffer.getInt(0));
            if (debugStatus) { debugWriter.println("Features length = " + gckFile.getLengthFeatures()); }
            
            logger.info("Region definitions length =" + gckFile.getLengthRegions() + "\n Feature definitions length =" + gckFile.getLengthFeatures());
        } catch (IOException ex) {
            logger.severe("Failed reading file header.");
        }
        logger.info("File header read successfully.");
    }
    
    /**
     * Extracts and stores region information.
     * 
     * Regions are basically how the sequence data is formatted in the gck file.
     * These can contain colours, fonts, font-sizes, and types, but we are only
     * interested in the colours at the moment.
     */
    private void readRegions() {
        logger.info("Reading region information.");
        buffer = ByteBuffer.allocate(GCKFile.REGION_DEF_LENGTH);
        try {
            //Set read position to the end of the sequence listing where region
            //definitions start.
            fileInputStream.getChannel().position(gckFile.getHeader().getHEADER_SIZE()+gckFile.getSequence().getLength());
            
            //Skip the offset and the sequence length entry.
            fileInputStream.skip(8);
            
            //Read the number of regions specified and allocate the needed memory.
            fileInputStream.read(buffer.array(), 0, 2);
            gckFile.setNumRegions(buffer.getShort(0));
            logger.info("Found " + gckFile.getNumRegions() + " regions.");
            gckFile.allocateRegions();
            if (debugStatus) {
                debugWriter.println("Starting reading regions, " + gckFile.getNumRegions() + " found.");
            }
            
            //Iterate through all the regions extracting and storing data.
            for (int i = 0; i < gckFile.getNumRegions(); i++) {
                //Read a full region record into the buffer.
                fileInputStream.read(buffer.array(), 0, buffer.capacity());
                if (debugStatus) {
                    for (int b = 0; b < buffer.array().length; b++) {
                        debugWriter.print(String.format("%02X", buffer.get(b)));
                        if ((b+1)%4 == 0) {
                            debugWriter.print(" ");
                        }
                    }
                    debugWriter.print("\n");
                }
                gckFile.getRegion(i).setStart(buffer.getInt(0) + 1);
                gckFile.getRegion(i).setEnd(buffer.getInt(4));
                gckFile.getRegion(i).setFontType(buffer.get(12));
                gckFile.getRegion(i).setColourRed(buffer.get(16));
                gckFile.getRegion(i).setColourGreen(buffer.get(18));
                gckFile.getRegion(i).setColourBlue(buffer.get(20));

                //If a region is black we do not display it. We assume that black
                //is the base colour thus all of these are just the normal un-
                //annotated sequence regions.
                if (((int)gckFile.getRegion(i).getColourRed() & 0xff) > 0 || ((int)gckFile.getRegion(i).getColourGreen() & 0xff) > 0 || ((int)gckFile.getRegion(i).getColourBlue() & 0xff) > 0) {
                    gckFile.getRegion(i).setToDisplay(true);
                }
                logger.info("Region " + i + " = " + gckFile.getRegion(i).getStart()+ "-" + gckFile.getRegion(i).getEnd());
            }           
        } catch (IOException ex) {
            logger.severe("Failed reading sequence regions.");
        }
        logger.info("Region information read successfully.");
    }
    
    /** 
     * Features are the various defined elements in the sequence.
     * 
     * These have direction as well as names.
     */
    private void readFeatures() {
        logger.info("Reading feature definitions.");
        try {
            //Set read position to the end of the regions, where the feature
            //definitions start.
            fileInputStream.getChannel().position(gckFile.getHeader().getHEADER_SIZE()+gckFile.getSequence().getLength()+gckFile.getLengthRegions() + 4);

            //Skip the offset and the sequence length entry.
            fileInputStream.skip(8);
            
            //Read the number of features specified.
            buffer = ByteBuffer.allocate(2);
            fileInputStream.read(buffer.array(), 0, 2);
            gckFile.setNumFeatures(buffer.getShort(0));
            logger.info("Found "+ gckFile.getNumFeatures() + " features.");
            if (debugStatus) {
                debugWriter.println("\nStarting reading features, " + gckFile.getNumFeatures() + " found.");
            }
            //Make sure we have at least one Feature.
            if (gckFile.getNumFeatures() > 0) {
                //Calculate the size of each record for a feature as these can
                //be variable. Usually either 0x5C or 0x5E.
                //6 bytes are subtracted as they are the sequence length and the
                //number of features.
                buffer = ByteBuffer.allocate((gckFile.getLengthFeatures()-6)/gckFile.getNumFeatures());
                gckFile.allocateFeatures();
                
                //Iterate through the features extracting and storing data.
                for (int i = 0; i < gckFile.getNumFeatures(); i++) {
                    
                    //Read a full feature record into the buffer. 
                    //IMPORTANT: This does not contain the name of the Feature,
                    //or any associated comments.
                    fileInputStream.read(buffer.array(), 0, buffer.capacity());
                    if (debugStatus) {
                        for (int b = 0; b < buffer.array().length; b++) {
                            debugWriter.print(String.format("%02X", buffer.get(b)));
                            if ((b+1)%4 == 0) {
                                debugWriter.print(" ");
                            }
                        }
                        debugWriter.print("\n");
                    }
                    gckFile.getFeature(i).setStart(buffer.getInt(0) + 1);
                    gckFile.getFeature(i).setEnd(buffer.getInt(4));
                    gckFile.getFeature(i).setType(buffer.getShort(14)); //Not sure how long and what the CDS/GENE definition contains, but it is 0 if it is but a GENE and larger otherwise.
                    // logger.info("" + buffer.getShort(14));
                    gckFile.getFeature(i).setStrand(buffer.get(30));
                    gckFile.getFeature(i).setColourRed(buffer.get(42));
                    gckFile.getFeature(i).setColourGreen(buffer.get(44));
                    gckFile.getFeature(i).setColourBlue(buffer.get(46));
                    
                    //If the feature does not have a unique identifier it will
                    //also not have a name entry, thus we have to set it explicitly.
                    if (buffer.getInt(48) == 0) {
                        gckFile.getFeature(i).setName("NONE");
                    }
                    logger.info("Feature " + gckFile.getFeature(i).getStart() + ".." + gckFile.getFeature(i).getEnd() + " Type = " + gckFile.getFeature(i).getType().dispName());
                }
            }
        } catch (IOException ex) {
            logger.severe("Failed reading features.");
        }
        logger.info("Feature information read successfully.");
    }
    
    /**
     * Read and connect the stored names with the features.
     * 
     * Should be called after the features have been read from the file.
     */
    private void readFeatureNamesAndComments() {
        logger.info("Reading feature names and comments.");
        buffer = ByteBuffer.allocate(0xffff);
        try {
            //Set the reading position to the end of the feature definitions.
            fileInputStream.getChannel().position(gckFile.getHeader().getHEADER_SIZE()+gckFile.getSequence().getLength()+gckFile.getLengthRegions()+gckFile.getLengthFeatures() + 8);
            
            //Iterate through the Features adding the names.
            for (int i = 0; i < gckFile.getNumFeatures(); i++) {
                
                //Skip feature if it does not have a stored name.
                if(!gckFile.getFeature(i).getName().equals("NONE")) {
                    
                    //Names are short and their length is stored in a byte variable.
                    //If the first byte is 0, then a comment follows as the length
                    //of a comment is stored in an int, but has to be less than
                    // 0x00ffffff
                    fileInputStream.read(buffer.array(), 0, 1);
                    if (buffer.get(0) != 0) {
                        fileInputStream.read(buffer.array(), 1, (int)buffer.get(0) & 0xff);
                        
                        //Need to convert all the bytes to chars so that we can 
                        //make a String, as GCK files use 1 byte chars.
                        char[] c = new char[buffer.get(0)];
                        for (int j = 0; j < c.length; j++) {
                            c[j] = (char)(buffer.get(j+1));
                        }
                        gckFile.getFeature(i).setName(String.valueOf(c));
                    } else {
                        gckFile.getFeature(i).setName("Feature" + i);
                    }
                    logger.info(gckFile.getFeature(i).getName() + " = name of " + i + ". feature");
                    
                    //Read the next byte if it is 0, there is a comment, otherwise it is the length of the next features name.
                    //IMPORTANT: It is possible to have a long enough comment, that the next byte is non-zero, but this is rare.
                    //It would need to be 0x80ffffff in length.
                    fileInputStream.read(buffer.array(), 0, 1);
                    fileInputStream.getChannel().position(fileInputStream.getChannel().position() - 1);
                    if (buffer.get(0) == 0) {
                        fileInputStream.read(buffer.array(), 0, 4);
                        int bufferLength = buffer.getInt(0);
                        logger.info("Needed buffer length: " + bufferLength);
                        fileInputStream.read(buffer.array(), 4, bufferLength);
                        char[] c = new char[buffer.getInt(0)];
                        for (int j = 0; j < c.length; j++) {
                            c[j] = (char)(buffer.get(j+4));
                        }
                        gckFile.getFeature(i).setComment(String.valueOf(c));
                    }
                }
            }
        } catch (IOException ex) {
            logger.severe("Failed reading feature names and comments");
        }
    }
    
    /**
     * Reads and stores the DNA sequence stored in the gck file.
     */
    private void readSequence() {
        buffer = ByteBuffer.allocate(gckFile.getSequence().getLength());
        logger.info("Sequence reading started.");
        if (buffer.capacity() > 0) {
            try {
                fileInputStream.getChannel().position(gckFile.getHeader().getHEADER_SIZE());
                fileInputStream.read(buffer.array(), 0, gckFile.getSequence().getLength());
                char[] c = new char[gckFile.getSequence().getLength()];
                for (int i = 0; i < gckFile.getSequence().getLength(); i++) {
                    c[i] = (char)(buffer.get());
                }
                gckFile.getSequence().setSequence(String.valueOf(c));
//                logger.info(sequence.getSequence());
            } catch (IOException ex) {
                logger.severe("Failed reading sequence.");
            }
        }
    }
    
    /**
     * Used to better analyse the gck file data.
     * 
     * Writes the byte sequence (in hex) of the various records found in the gck
     * file.
     */
    public void debug(File debugFile) throws IOException {
        logger.info("Debugging started.");
        debugWriter = new PrintWriter(debugFile);
        debugStatus = true;
        readFileHeader();
        readRegions();
        readFeatures();
        debugWriter.close();
    }
    
    private FileInputStream fileInputStream;
    private GCKFile gckFile;
    private final static Logger logger = Logger.getLogger("GCK_Converter_logger");
    private ByteBuffer buffer;
    private boolean debugStatus;
    private PrintWriter debugWriter;
}
