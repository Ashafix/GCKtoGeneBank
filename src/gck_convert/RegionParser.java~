package gck_convert;

import gckfilestructure.GCKFile;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.LinkedList;
import gckfilestructure.RegionType;
//import gckfilestructure.Feature;
//import gckfilestructure.Region;

/**
 * RegionParser is responsible for the pruning, ordering, and sorting of the 
 * regions and features extracted from a GCK file.
 * 
 * It has a number of methods to validate and modify the extracted list of 
 * regions and features.
 * 
 * @author Matyas Medzihradszky
 * @version 0.1
 */
public class RegionParser {
    
    /**
     * Creates a new RegionParser connected to an existing GCKFile.
     * 
     * @param gckFile A GCKFile object. Regions and Features are used from this.
     * @param parseLevel The level of pruning desired. Only used for the parseRegions method.
     */
    public RegionParser(GCKFile gckFile, ParseLevel parseLevel) {
        super();
        this.gckFile = gckFile;
        this.parseLevel = parseLevel;
    }
    
    /**
     * Pairs a region with the corresponding feature if it exists.
     * 
     * This is needed because GCK files store coloured regions of the sequence and
     * a corresponding defined sequence separately. Without a clear way to connect
     * the two.
     */
    public void pairRegionsWithFeatures() {
        //Pair regions to features if it is possible.
        //Regions are not always the same length as the corresponding feature because
        //features are only the protein sequence without stops or leading bases.
        //Thus allow +- 5 bp difference on both sides.
        for (int i = 0; i < gckFile.getNumRegions(); i++) {
            for (int j = 0; j < gckFile.getNumFeatures(); j++) {
                if(     gckFile.getRegion(i).getStart() - gckFile.getFeature(j).getStart() <= 5 &&
                        gckFile.getRegion(i).getStart() - gckFile.getFeature(j).getStart() >= -5 &&
                        gckFile.getRegion(i).getEnd() - gckFile.getFeature(j).getEnd() <= 5 && 
                        gckFile.getRegion(i).getEnd() - gckFile.getFeature(j).getEnd() >= -5) {
                    //If a match has been found copy the colour data from the region.
                    //TODO - check if it ever can happen that the region is black while the feature has colour.
                    gckFile.getFeature(j).setColourRed(gckFile.getRegion(i).getColourRed());
                    gckFile.getFeature(j).setColourGreen(gckFile.getRegion(i).getColourGreen());
                    gckFile.getFeature(j).setColourBlue(gckFile.getRegion(i).getColourBlue());
                    //Set the region's display attribute to false.
                    gckFile.getRegion(i).setToDisplay(false);
                }
            }
        }
    }
    
    /**
     * Determines which features and regions to keep.
     * 
     * Dependent on a given ParseLevel tries to reduce the number of features and
     * regions to be included in the final GeneBank file.
     * This is needed because GCK includes a lot of automatic annotations that only
     * make the final file cluttered.
     */
    public void parseRegions() {
        //Do things from here on at ParseLevel.LOW
        if (parseLevel.greater(ParseLevel.NONE)) {
            //Remove duplicate features keeping only the first one.
            //Make sure the direction is also the same.
            for (int i = 0; i < gckFile.getNumFeatures()-1; i++) {
                for (int j = i + 1; j < gckFile.getNumFeatures(); j++) {
//                    if(gckFile.getFeature(i).getStart() == gckFile.getFeature(j).getStart() && gckFile.getFeature(i).getEnd() == gckFile.getFeature(j).getEnd()) {
//                        gckFile.getFeature(j).setToDisplay(false);
//                    }
                    if (gckFile.getFeature(i).getStart() - gckFile.getFeature(j).getStart() <= 5 &&
                        gckFile.getFeature(i).getStart() - gckFile.getFeature(j).getStart() >= -5 &&
                        gckFile.getFeature(i).getEnd() - gckFile.getFeature(j).getEnd() <= 5 && 
                        gckFile.getFeature(i).getEnd() - gckFile.getFeature(j).getEnd() >= -5) {
//                        gckFile.getFeature(j).setToDisplay(false);
                        if (gckFile.getFeature(i).getStrand() == gckFile.getFeature(j).getStrand()) {
                            gckFile.getFeature(j).setToDisplay(false);
                        }
                    }
                }
            }
            //Do things from here on at ParseLevel.MEDIUM
            if (parseLevel.greater(ParseLevel.LOW)) {
                for (int i = 0; i < gckFile.getNumRegions(); i++) {
                    //Remove regions smaller than 10 bp.
                    if ((gckFile.getRegion(i).getEnd()-gckFile.getRegion(i).getStart()) <= 10) {
                        gckFile.getRegion(i).setToDisplay(false);
                    }
                }
                
                for (int i = 0; i < gckFile.getNumFeatures(); i++) {
//                    if (gckFile.getFeature(i).getName().contains("berhang") ||
//                        gckFile.getFeature(i).getName().contains("Construct:") ||
//                        gckFile.getFeature(i).getName().contains("copy") ||
//                        gckFile.getFeature(i).getName().equals("NONE")) {
                    if (gckFile.getFeature(i).getType() == RegionType.EXCLUDE) {
                        //Remove various regions based upon names.
                        gckFile.getFeature(i).setToDisplay(false);
                    }
                }            
                //Remove features within other features.
                //Do things from here on at ParseLevel.HIGH
                if (parseLevel.greater(ParseLevel.MEDIUM)) {
                    for (int i = 0; i < gckFile.getNumFeatures() - 1; i++) {
                        for (int j = i + 1; j < gckFile.getNumFeatures(); j++) {
                            if(gckFile.getFeature(i).getStart() <= gckFile.getFeature(j).getStart() && gckFile.getFeature(i).getEnd() >= gckFile.getFeature(j).getEnd()) {
                                gckFile.getFeature(j).setToDisplay(false);
                            }
                            if(gckFile.getFeature(j).getStart() <= gckFile.getFeature(i).getStart() && gckFile.getFeature(j).getEnd() >= gckFile.getFeature(i).getEnd()) {
                                gckFile.getFeature(i).setToDisplay(false);
                            }
                        }
                    }
                    //Do things from here on at ParseLevel.HIGHEST
                    if (parseLevel.greater(ParseLevel.HIGH)) {
                        //Remove any regions within defined features.
                        for (int i = 0; i < gckFile.getNumFeatures(); i++) {
                            for (int j = 0; j < gckFile.getNumRegions(); j++) {
                                if (gckFile.getRegion(j).getStart() >= gckFile.getFeature(i).getStart() && gckFile.getRegion(j).getEnd() <= gckFile.getFeature(i).getEnd()) {
                                    gckFile.getRegion(j).setToDisplay(false);
                                }
                            }
                        }
                    }
                }
            }
        }        
    }
    
    /**
     * Assigns types to the regions bases upon their names if possible.
     * 
     * Uses defined patterns for determining if a feature is part of a group or
     * not. The patterns are defined in the class definition or in a separate
     * library file.
     */
    public void idRegions(LinkedList<String[]> library) {
        //Put back any features containg primer binding sites
        for (int i = 0; i < gckFile.getNumFeatures(); i++) {
            for (String[] s: library) {
                currentPattern = Pattern.compile(s[0]);
                matcher = currentPattern.matcher(gckFile.getFeature(i).getName().toLowerCase());
                if (matcher.find()) {
                    gckFile.getFeature(i).setType(RegionType.valueOf(s[1].toUpperCase()));
                }
            }
        }
     }
    
    /**
     * Modifies feature names to be acceptable GeneBank names if needed.
     */
    public void validateNames() {
        for (int i = 0; i < gckFile.getNumFeatures(); i++) {
            String name = gckFile.getFeature(i).getName();
            if (name.contains("=")) {
                gckFile.getFeature(i).setName(name.replace("=", "_"));
            }
        }
    }
    
    public void setParseLevel(ParseLevel parseLevel) {
        this.parseLevel = parseLevel;
    }
    
    private GCKFile gckFile;
    private ParseLevel parseLevel;
    private Pattern primerPattern = Pattern.compile("^A\\d{5}$");
    private Pattern currentPattern;
    private Matcher matcher;
}
